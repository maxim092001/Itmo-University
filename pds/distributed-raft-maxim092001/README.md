# Distributed Raft

В этом задании вы реализуете алгоритм Raft для распределенного консенсуса на основании статьи
[In Search of an Understandable Consensus Algorithm (Extended Version)](https://raft.github.io/raft.pdf).

## Задача

В файле [`src/Process.kt`](src/Process.kt) находится описание интерфейса, который вам предстоит реализовать.
Свой код вы должны писать на языке Kotlin в файле [`src/ProcessImpl.kt`](src/ProcessImpl.kt). 
**Не забудьте указать свое имя и фамилию в файле с вашим решением.**

Допустима также реализация на Java. Для этого удалите `ProcessImpl.kt` и вместо него напишите файл
`ProcessImpl.java` с классом `raft.ProcessImpl`, который реализует интерфейс `raft.Process` и имеет 
публичный конструктор, принимающий ссылку на объект реализующий интерфейс `raft.Environment`. 
Шаблон для такого класса дан в файле [`src/ProcessJavaImpl.java`](src/ProcessJavaImpl.java).

### Проект

Для работы над проектом рекомендуется импортировать Gradle проект 
[`build.gradle.kts`](build.gradle.kts) в IntelliJ IDEA, но это не обязательно. Работу и тестирование
проекта можно также производить из командной строки. 

### Окружение процесса

Тестовая система будет запускать ваш код в нескольких копиях (процессах), каждому из которых выдан уникальный 
идентификатор начинающийся с единицы. Через ссылку на объект [`Environment`](src/Environment.kt) ваш процесс
может узнать конфигурацию системы и общаться с другими процессами:

* `env.processId` &mdash; возвращается идентификатор вашего процесса (нумерация с единицы).
* `env.nProcesses` &mdash; возвращает общее число процессов.
* `env.send(destId, message)` &mdash; посылает сообщение процессу с номером `destId` (нумерация с единицы).
* `env.startTimeout(timeout)` &mdash; должен быть вызвать вашим процессом для того, чтобы ожидать определенное время.
  Каждый вызов `startTimeout` сбрасывает предыдущее ожидание и начинает отсчет времени ожидания заново. 
  Есть две типа ожидания, задаваемых параметром `timeout`:
  * `Timeout.ELECTION_TIMEOUT` &mdash; ожидание ответа на голосование процессом Candidate и ожидание сообщений 
     `AppendEntryRpc` процессом Follower от лидера. Величина такого ожидания выбирается системой псевдослучайно.  
  * `Timeout.LEADER_HEARTBEAT_PERIOD` &mdash; ожидание лидером времени когда нужно послать всем процессам 
     сообщение `AppendEntryRpc` сообщая, что лидер жив. Величина такого ожидания постоянна. 
* `env.onClientCommandResult(result)` &mdash; должно быть вызвать после обработки сообщения от клиента.
* `env.storage` &mdash; ссылка на реализацию [`Storage`](#storage) (описание будет дано ниже).
* `env.machine` &mdash; ссылка на реализацию [`StateMachine`](#state-machine) (описание будет дано ниже).

### Методы процесса

Методы вашего класса [`ProcessImpl.kt`](src/ProcessImpl.kt) 
будут вызываться из главного потока процесса в следующих случаях:

* `onTimeout()` &mdash; вызывается если было превышено время ожидания события, при условии, что процесс до этого 
  вызывал `env.startTimeout(...)`. Чтобы снова ожидать, ваш процесс должен снова вызвать `env.startTimeout(...)`.
* `onMessage(srcId, message)` &mdash; вызывается при получении сообщения от другого процесса с номером `srcId` 
  (нумерация с единицы), которое было послано другим процессом через `env.send(...)`.
  Между каждой парой процессов гарантируется FIFO порядок передачи сообщений.
* `onClientCommand(command)` &mdash; вызывается в случае поступления этому процессу команды от клиента, 
  которую надо выполнить над машиной состояний. 

### Алгоритм

Вам необходимо реализовать только базовую версию алгоритма Raft, без различных описанных в статье улучшений типа
"log compaction" и посылки нескольких записей в сообщение AppendEntries &mdash; вам нужно будет посылать
только по одной записи в каждом сообщении. Однако, в алгоритм так же внесены некоторые практически-полезные изменения,
которые вам надо будет реализовать для выполнения задания. Они описаны ниже.

#### Типы сообщений

В статье алгоритм Raft использует четыре типа сообщений. Для них вам даны соответствущие классы,
описанные в файле [`src/Message.kt`](src/Message.kt):

* `Message.AppendEntryRpc` соответствует запросу "AppendEntries RPC" в статье и имеет свойства:
  * `term` &mdash; как в статье;
  * `prevLogId` &mdash; содержит пару `prevLogIndex` и `prevLogTerm` из статьи в одном объекте типа `LogId`;
  * `leaderCommit` &mdash; как в статье;
  * `entry` содержит либо одну запись типа `LogEntry` либо `null` для сообщений heartbeat, которые должен периодически посылать лидер.
  * В статье еще упоминается `leaderId`. Его роль выполняет параметр `srcId`, который ваш процесс получает при вызове `onMessage(...)`.

* `Message.AppendEntryResult` соответствует ответу на запрос "AppendEntries RPC" в статье и имеет свойства:
  * `term` &mdash; как в статье;
  * `lastIndex` &mdash; играет роль `success` из статьи, но несет больше информации:
    * равен `null`, если предыдущая запись в журнале не совпала (`success = false`);
    * равен последнему индексу в получившемся журнале, если предыдущая запись в журнале совпала (`success = true`);
      * если запрос на добавление не содержал новую запись (`entry == null`), то это индекс совпавшей записи журнала (`prevLogId.index`);
      * если запрос на добавление содержал новую запись (`entry != null`), то это индекс новой записи (`entry.index`).

Дополнительная информация в `AppendEntryResult`, которую несет поле `lastIndex`, упрощает реализацию обработки этого
сообщения в коде лидера, которая кратко описана в статье как "If successful: update nextIndex and matchIndex for follower".

* `Message.RequestVoteRpc` соответствует запросу "RequestVote RPC" в статье и имеет свойства:
  * `term` &mdash; как в статье;
  * `lastLogId` &mdash; содержит пару `lastLogIndex` и `lastLogTerm` из статьи в одном объекте типа `LogId`;
  * В статье еще упоминается `candidateId`. Его роль выполняет параметр `srcId`, который ваш процесс получает при вызове `onMessage(...)`.

* `Message.RequestVoteResult` соответствует ответу на запрос "RequestVote RPC" в статье и имеет свойства:
  * `term` &mdash; как в статье;
  * `voteGranted` &mdash; как в статье;

### Получение запросов от клиента любым узлом

**В статье предполагается, что команды от клиентов всегда принимает лидер. Вам же надо реализовать Raft
таким образом, чтобы команды от клиентов мог принимать любой процесс.**
То есть, обработка `onClientCommand(command)` должна быть реализована как для Follower, так и для Candidate:

* Follower должен переслать клиентскую команду лидеру. В ситуации, когда follower еще не знает кто лидер, он должен
  положить команду в свою локальную очередь. Как только лидер станет известен (от него получено сообщение `AppendEntryRpc`),  
  все команду из очереди должны быть пересланы лидеру в исходном порядке. Аналогично, если процесс сам станет 
  лидером, то он должен обработать все команды из очереди. 
* Candidate так же кладет команды в очередь. Дальше кандидат либо станет лидером и обработает все эти команды либо 
  получит роль follower другого лидера и перешлет ему все команды. 

Каждая команда представляется классом `Command` в файле [`src/StateMachine.kt`](src/StateMachine.kt). Свойство
`Command.processId` всегда равно идентификатору процессу, от которого команда поступила в самом начале, то есть 
номеру процесса, в котором произошел вызов `onClientCommand`. При дальнейшей пересылке весь объект `Command`
пересылает в неизменном виде и значение свойства `processId` позволяет установить, какой процесс ожидает ответа
на команду. 

Для пересылки команд от клиентов лидеру есть два дополнительных типа сообщений.

* `Message.ClientCommandRpc` посылается лидеру от follower или candidate процесса и имеет свойства:
  * `term` &mdash; как в статье, для однообразности. Ситуация, когда лидер получит `ClientCommandRpc` с более новым
  значением `term` не может получиться, так как follower и candidate шлют сообщение `ClientCommandRpc` только лидеру
  соответствующего терма. Однако, такое сообщение может прийти процессу, который уже не является лидером, а играет
  роль follower или candidate более нового term. Такой процесс должен обработать это сообщение так же как и вызов 
  `onClientCommand(command)`.
  * `command` &mdash; команда от клиента. 

* `Message.ClientCommandResult` посылается лидером после того как команда была применена к машине состояний
  (то есть её запись в журнале была committed) и получает ответ. Она имеет свойства:
  * `term` &mdash; как в статье. Должна обрабатываться так же как и другие сообщения от лидера. При получении более свежего
  значения `term`, процесс должен принимать роль follower.
  * `result` &mdash; результат исполнения команды. 

При получении `ClientCommandResult` процесс должен вызвать `env.onClientCommandResult(result)`.

Обратите внимание, что одна команда может быть несколько раз переслана сообщениями `ClientCommandRpc`, в случае если
лидер успевает поменяться в процессе пересылки команды. Однако результат выполнения команды будет переслан ровно один раз исходному
процессу сообщением `ClientCommandResult`.

Такая реализация не гарантирует что команда от клиента будет обязательно выполнена и не гарантирует что на выполненную команду
будет обязательно получен ответ. Очередь команд, хранящаяся процессом, будет потеряна при перезапуске этого процесса, а ответ
на команду будет потерян если в исходном процессе произошел сбой. Однако, если в системе нет сбоев, то все команды, 
поступающие от любого процесса, будут исполнены и ответы на них будут получены.

> Данная реализация дает гарантию "at most once" выполнения команд. На основании этой гарантии, можно воспользоваться 
> стандартными подходами для получения "exactly once" гарантии выполнения команд даже в случае сбоев. 
> Но это уже выходит за рамки данного задания. 

**Ваша реализация алгоритма Raft не должна как-либо зависеть от деталей реализации класса `Command` и никогда 
не должна заглядывать внутрь объекта `Command`**. В частности, после `Command.commandId` используется исключительно для
упрощения отладки кода и не является уникальным идентификатором команды, а некоторые тесты генерируют его случайным образом.  

### Storage

Для хранения "persistent state", который должен сохранятся при перезапуске процесса, вам дана реализация класса
`Storage` в файле [`src/Storage.kt`](src/Storage.kt). Ссылка на реализацию доступна как `env.storage`. 
Класс `Storage` предоставляет вам следующие методы:

* `storage.readPersistentState()` &mdash; читает объект `PersistentState` в котором хранятся поля состояния процесса:
  * `currentTerm` &mdash; текущий терм, как в статье;
  * `votedFor` &mdash; отданный голос, как в статье.
* `storage.writePersistentState(state)` &mdash; сохраняет объект `PersistentState`.
* `storage.readLastLogId()` &mdash; читает `LogId` (пара `index` и `term`) последней записи журнала.
  Если журнал пуст, то это пара `index=0` и `term=0` представленная объектом `START_LOG_ID`. 
* `storage.readLog(index)` &mdash; читает запись из журнала по заданному индексу (начиная с 1).
* `storage.appendLogEntry(entry)` &mdash; дописывает запись в журнал. При этом, запись с таким же индексом и все
  записи с большим индексом выкидываются из журнала. 

### State machine

Для обработки команд от клиентов вам дана реализация класса `StateMachine` 
в файле [`src/StateMachine.kt`](src/StateMachine.kt). Ссылка на реализацию доступна как `env.machine`. 
Там есть единственный метод `machine.apply(command)` выполняющий команду типа `Command`. 
Команды это простые присваивания `<key> = <value>`. 

**Команды должны применяться в `StateMachine` только когда они "committed" в Raft.**

Обратите внимание, что при запуске алгоритма никакие записи не считаются committed и `StateMachine` будет находиться в 
своем изначальном, пустом состоянии. Более того, даже когда избран лидер, 
никакие записи из журнала автоматом не становятся committed. 
Как описано в разделе "5.4.2 Committing entries from previous terms",
только после того как лидер примет и исполнит свою первую команду, будут committed и предыдущие записи из журнала. 

## Отладка кода распределенной системы

Для запуска и отладки кода предлагается ряд готовых инструментов. 
Первый инструмент позволяет запустить реальную распределенную систему, вручную создавать на неё воздействие и
изучать как она работает.

### Конфигурация системы и состояние

Конфигурация запускаемой распределенной системы находится в файле [`system.properties`](system.properties) и состоит
из перечисления процессов (узлов) системы и их адресов. По умолчанию система сконфигурирована для работы с 5-ю процессами,
запускаемыми на одной машине. Для отладки своего кода эта конфигурация может быть изменена.

> Проще отлаживать код с тремя процессами. Этого можно добиться закомментировав последние две строки в 
> [`system.properties`](system.properties)

Еще два дополнительных параметра могут быть удобны для отладки:

* `heartbeatTimeoutMs` &mdash; интервал посылки сообщений лидером (`LEADER_HEARTBEAT_PERIOD`).  
  Оно так же используется как база для выбора времени ожидания сообщения от лидера (`ELECTION_TIMEOUT`), в 
  интервале от него, до два раза большего интервала. Уменьшение этого времени приведет к более быстрому выбору лидеру
  и к более частой посылке сообщений.
* `heartbeatRandom` &mdash; по умолчанию, для упрощения отладки, интервалы ожиданий выбираются не случайно, а так, чтобы
  процесс с меньшим номером ждал меньше. Таким образом, лидером будет всегда становится живой процесс с наименьшим номером.

Состояние каждого узла сохраняется в файл `node${id}.storage.txt`. При перезапуске состояние восстанавливается.
Для сброса состояния надо удалить эти файлы перед запуском. 

### Запуск одного процесса

Запустить процесс можно одним из двух способов:

* Запустив `main` функцию в файле [`src/system/Node.kt`](src/system/Node.kt), передав ей в качестве аргумента номер процесса.
* Из командной строки `gradlew node -PprocessId=<id>`.

На экране будет виден подробный журнал работы процесса. Все посылаемые и принимаемые сообщения и всё взаимодействие
с окружением всегда выводятся системой на экран. В консоли можно вводить следующие команды:

* `set <key> <value>` &mdash; передает процессу команду установить `<key> = <value>` через вызов `onClientCommand`.
* `dump` &mdash; выводит на консоль машину состояний процесса, то есть состояние с учетом всех committed команд. 
* `restart` &mdash; пересоздает реализацию процесса заново (имитирует его перезапуск).
* `stop` &mdash; останавливает работу и выходит.
* Нажатие ENTER (ввод пустой строки) выдает подсказку. 

### Запуск всех процессов одновременно

Запустить все процессы одновременно можно одним из двух способов:

* Запустив `main` функцию в файле [`src/system/System.kt`](src/system/System.kt).
* Из командной строки `gradlew system`.

На экране будет виден подробный журнал работы всех процессов. 
В консоли можно вводить следующие команды:

* `<pid> log [...]` &mdash; управляет выводом журнала на экран:
  * `<pid> log` &mdash; показывает журнал только от процесса `<pid>`, скрывая остальные;
  * `<pid> log on` &mdash; включает показ журнала от процесса `<pid>`;
  * `<pid> log off` &mdash; выключает показ журнала от процесса `<pid>`.
* `<pid> set <key> <value>` &mdash; передает процессу `<pid>` команду установить `<key> = <value>` через вызов на нем `onClientCommand`.
* `<pid> dump` &mdash; выводит на консоль машину состояний процесса `<pid>`.
* `<pid> stop` &mdash; останавливает работу процесса `<pid>`.
* `<pid> start` &mdash; заново стартует процесс `<pid>`.
* `dump` &mdash; выводит на консоль машину состояний всех процессов (посылает `dump` всем процессам)
* `exit` &mdash; останавливает работу все процессов.
* Нажатие ENTER (ввод пустой строки) выдает подсказку.

## Тестирование

Полное тестирования реализации происходит путем сборки проекта и запуска всех тестов командой `gradlew build`.
Есть две категории тестов. 

### Распределенный функциональный тест

* Запустив тест в файле [`test/DistributedTest.kt`](test/DistributedTest.kt).
* Из командной строки `gradlew distributedTest`.

Тест запускает реальную распределенную систему из 5 узлов (согласно конфигурации в [`system.properties`](system.properties)),
но с маленькими времена ожидания, для скорейшего прохождения теста. На этой системе последовательно выполняются различные
клиентские запросы и проверяется их корректное выполнение. В том числе есть вариант сценария 
с периодическим перезапуском процессов.  

### Тест отдельных аспектов алгоритма

* Запустив тест в файле [`test/MockTest.kt`](test/MockTest.kt).
* Из командной строки: `gradlew test`.

Тест проверяет различные аспекты реализованного алгоритма Raft в изоляции. Создаются различные внешние стимулы 
в виде вызова на процессе методов `onXxx` и проверяется соответствие реакции процесса (в виде вызовов `env.xxx`) на
соответствие описанию алгоритма Raft.

## Формат сдачи

Выполняйте задание в этом репозитории. 
**Ваш код должен быть реализован в одном файле [`src/ProcessImpl.kt`](src/ProcessImpl.kt) или `src/ProcessImpl.java`**.

Инструкции по сдаче заданий находятся в 
[этом документе](https://docs.google.com/document/d/1GQ0OI_OBkj4kyOvhgRXfacbTI9huF4XJDMOct0Lh5og). 
